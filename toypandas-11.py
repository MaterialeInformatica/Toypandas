# -*- coding: utf-8 -*-
"""ToyPandas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BAYhl0fjoBJSE6N9f-brQXRWcS9KSWZu
"""

import warnings # to avoid future worning from pandas
warnings.simplefilter(action='ignore', category=FutureWarning)

import pandas as pd 
from pandas import Series, DataFrame, concat
from numpy import nan, isnan
import re
import itertools
import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 20, 'figure.figsize': (10, 8)}) # set font and plot size to be larger

# could be improved by also overriding loc
# "ilocate": iloc (numerical index)
# sempre reindex (anche se faccio una query, risultato avr√† indici ordinati da 0)
# sum(), mean() stampa ancora tipi di dato originale
# describe is ok


class Locating_s(pd.core.indexing._iLocIndexer):
  def __init__(self, val):
    super().__init__("iloc", val)
    self.s = pd.core.frame.Series(val)
  def __getitem__(self, *args):
    # series with one element lost their key
    #print(args)
    #print(type(args[0]))
    if(isinstance(args[0],slice)):
      return series(super().__getitem__(args[0]))
    elif (self.s.empty or (len(self.s.index) <= args[0])):
      raise IndexError("Series indexer is out-of-bounds")
    else: 
      return super().__getitem__(args[0]) # ho tolto casting a series()
  def __setitem__(self, *args):
    if(len(self.s.index) > args[0]):
      if(len(self.s.index) == 1):
        #self.s.astype(type(args[1]))
        return series(super().__setitem__(args[0],args[1]))
      else:
        return series(super().__setitem__(args[0],args[1]))
    else:
      raise IndexError("Series indexer is out-of-bounds")

class Locating(pd.core.indexing._iLocIndexer):
  def __init__(self, val):
    super().__init__("iloc", val)
    self.df = pd.core.frame.DataFrame(val)
  def __getitem__(self, *args):
    if (isinstance(args[0], int)):
      #print(series(super().__getitem__(args[0])))
      return series(super().__getitem__(args[0]))
    else:
      return dataframe(super().__getitem__(args[0]))
  def __setitem__(self, *args):
    if(len(self.df.index) > args[0]):
      return dataframe(super().__setitem__(args[0],args[1]))
    else:
      raise IndexError("Series indexer is out-of-bounds")

class dataframe(pd.core.frame.DataFrame):
  def __init__(self, *args):
    super().__init__(*args)
    
  @property
  def indexlocate(self):
    return Locating(self)

  def show(self):
    return self
 
  def __getitem__(self, *args):
    if ((type(args) == tuple) and (type(args[0]) == str)):
      return series(super().__getitem__(args[0]))
    
    elif ((type(args) == tuple) and (type(args[0]) == int)):
      return series(super().__getitem__(args[0]))

    elif ((type(args) == tuple) and (type(args[0]) == float)):
      return series(super().__getitem__(args[0]))
    
    elif (type(args) == tuple and type(args[0]) == tuple):
      d = dataframe()
      list_col = list()
      for elem in args[0]:
        s = series(super().__getitem__(elem))
        list_col.append(s)
      tuple_col = tuple(list_col)
      d = concat_df(tuple_col)
      return d
   
    elif (isinstance(args[0], pd.core.series.Series)):
      temp = super().__getitem__(args[0])
      temp.reset_index(drop=True, inplace=True)
      return dataframe(temp)

# semplificazione: se aggiungo riga + lunga, perdo dati aggiuntivi, se + corta mette dei nan
# one row (series), more rows (dataframe: you can also use concat())
  def append(self, obj):
    if(not(isinstance(obj, series)) and not(isinstance(obj,dataframe))):
      raise TypeError("Can only add series or dataframe")

    elif(isinstance(obj, series)):
      #obj.name = len(self.index)
      #pd.concat([obj,self.loc[:]]).reset_index(drop=True)
      #self.__init__(super().append(obj, ignore_index=True)) #append
      s = series()
      for v, n in zip(obj.values, self.columns):
        s.loc[n] = v
      s.name = len(self.index)
      self.__init__(super().append(s, ignore_index=True))
      
      #self.__init__(super().append(obj, ignore_index=False))
      #return self
      #temp.reset_index(drop=True, inplace=True)
      #self.loc[len(self.index)] = obj
    elif(isinstance(obj, dataframe)):
      for k,r in obj.iterrows():
        self.loc[len(self.index)] = r
      #return dataframe(self)
    
  def drop(self, item):
    if(isinstance(item, int)):
      super().drop(item, inplace=True)
      self.reset_index(drop=True, inplace=True)
    elif(isinstance(item, str)):
      super().drop(item, inplace=True, axis=1)



  def dropna(self, **kargs):
    if (len(kargs) > 1):
      raise Exception("Error. Axis must be 0 or 1 (row or column).")  
    elif ((kargs == {}) or (next(iter(kargs.keys())) == "axis" and next(iter(kargs.values())) == 0)):
      temp = super().dropna()
      if (len(temp.index) == 1):
        return series(temp)
      else:
        return dataframe(temp)

    elif (next(iter(kargs.keys())) == "axis" and next(iter(kargs.values())) == 1):
      temp = super().dropna(axis=1)
      if (len(temp.index) == 1):
        return series(temp)
      else:
        return dataframe(temp)
    else:
      raise ValueError("The axis value must be 0 or 1 (row or column respectively)")   

  def drop_duplicates(self):
    #temp = super().drop_duplicates(inplace=True)
    self = super().drop_duplicates()
    if (len(self.index) == 1):
        return series(self)
    else:
      return dataframe(self)

  def isnull(self):
    return dataframe(super().isnull())


  def rename(self, *args):
    if (len(args) == 2):
      super().rename(columns={args[0]:args[1]}, inplace=True)
    else:
      raise ValueError("I expect two arguments: old column name, new column name")
    #elif (len(args) == 1 and isinstance(args[0], series) and (len(args[0])==len(self.columns))):
    #  old = list()
    #  for c in self.columns:
    #    old.append(c)
    #  for i in args[0].index:
    #    super().rename(columns={old[i]:args[1]}, inplace=True)


   # for key,value in kargs.items():
   #   super().rename(columns={key:value}, inplace=True)


class series(pd.core.series.Series):
  
  def __init__(self, *args):
    if(len(args) == 0):
      super().__init__()
    #elif (len(args)>1 and isinstance(args[0], pd.core.series.Series)): #controlla che con uello sopra ancora funion
    elif (isinstance(args[0], pd.core.series.Series)): 
      super().__init__(args[0])
    else:
      arg_list = list()
      for elem in args:
        arg_list.append(elem)
      super().__init__(arg_list)

  def __add__(self, other):
    return series(super().__add__(other))
    
  def __getitem__(self, *args):
    #print(type(args))
    #print(args)
    if isinstance(args[0], pd.core.series.Series):
      temp = super().__getitem__(args[0])
      temp.reset_index(drop=True, inplace=True)
      return series(temp)


  @property
  def indexlocate(self):
    return Locating_s(self)

  def apply(self, function):
    aux = series(super().apply(function))
    return aux

  def append(self,elem):
    if(len(self) <= 1):
      self.astype(type(elem))
      self.loc[len(self)] = elem
    else:
      self.loc[len(self)] = elem

  def drop(self, *elem):
    if (len(elem) == 0):
      size = self.size - 1
      super().drop(size, inplace=True) 
      self.reset_index(drop=True, inplace=True)
    else:
      try:
        super().drop(elem[0], inplace=True)
        self.reset_index(drop=True, inplace=True)
      except KeyError:
        print("Index might not exist")

  def astype(self, tp):
    self = series(super().astype(tp, copy=False))
    return self

    #return serie(super().astype(tp, copy=False))
  def dropna(self):
    self = pd.core.series.Series(self)
    self = self.dropna()
    self.reset_index(drop=True, inplace=True)
    return series(self) 
    
  def show(self):
    tipi = set()
    if (len(self.index) == 0):
      print("Empty series")
    for elem in self.index:
      if (pd.isnull(self.loc[elem])):
        print(elem, "NaN")
      else:
        print(elem, self.loc[elem])
      tipi.add(type(self.loc[elem]))
    if (len(tipi) > 1):
      print("name: ", self.name, " dtype: object")
    else:
      tipi = str(tipi)
      if(tipi == "{<class 'numpy.int64'>}" or tipi == "{<class 'int'>}"):
        print("name: ", self.name, " dtype: int")
      if(tipi == "{<class 'str'>}"):
        print("name: ", self.name, " dtype: str")
      if(tipi == "{<class 'numpy.float64'>}" or tipi == "{<class 'float'>}"):
        print("name: ", self.name, " dtype: float")
      if(tipi == "{<class 'numpy.bool_'>}" or tipi == "{<class 'bool'>}"):
        print("name: ", self.name, " dtype: bool")
      #sys.stdout = open(os.devnull, 'w')
      #return self

  def fillna(self, ph):
    series(super().fillna(ph, inplace=True))




def concat(*arg):
  lista = list()
  df = True
  for a in arg:
    lista.append(a)
    df = df and isinstance(a,dataframe) # concat dataframes or series
  if(df == True):
    return dataframe(pd.concat(lista, ignore_index=True))
  else:
    return dataframe(pd.concat(lista, axis = 1))

def concat_df(tpl):
  lista = list()
  for a in tpl:
    lista.append(a)
  return dataframe(pd.concat(lista, axis = 1))


#def series(*arg):
#  lista = list()
#  for elem in arg:
#    lista.append(elem)
#  return series(lista)

# POsso specificare la colonna per index oppure default (indice numerico da 0)
def read_csv(csv, **kwargs):
  # transforming kwargs into a string
  if(len(kwargs)>1):
    string = str(list(kwargs.values()))
    value_str = re.sub("\['", "", string)
    value_str = re.sub("'\]","", value_str)
    return dataframe(pd.read_csv(csv, index_col = value_str))
  else:
    return dataframe(pd.read_csv(csv, index_col = False))